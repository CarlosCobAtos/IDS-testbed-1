<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SelfDescriptionPersistenceAndIndexing.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">open-broker-common</a> &gt; <a href="index.source.html" class="el_package">de.fraunhofer.iais.eis.ids.broker.core.common.persistence</a> &gt; <span class="el_source">SelfDescriptionPersistenceAndIndexing.java</span></div><h1>SelfDescriptionPersistenceAndIndexing.java</h1><pre class="source lang-java linenums">package de.fraunhofer.iais.eis.ids.broker.core.common.persistence;

import de.fraunhofer.iais.eis.*;
import de.fraunhofer.iais.eis.ids.broker.core.common.impl.SelfDescriptionPersistenceAdapter;
import de.fraunhofer.iais.eis.ids.component.core.RejectMessageException;
import de.fraunhofer.iais.eis.ids.index.common.persistence.*;
import de.fraunhofer.iais.eis.ids.index.common.persistence.spi.Indexing;
import de.fraunhofer.iais.eis.ids.jsonld.Serializer;
import org.apache.jena.rdf.model.Model;
import org.apache.jena.rdf.model.ModelFactory;
import org.apache.jena.rdf.model.ResourceFactory;
import org.apache.jena.riot.RDFDataMgr;
import org.apache.jena.riot.RDFLanguages;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.net.ConnectException;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.charset.StandardCharsets;
import java.util.*;

/**
 * This class takes care of persisting and indexing any changes to connectors that are announced to the broker
 */
public class SelfDescriptionPersistenceAndIndexing extends SelfDescriptionPersistenceAdapter {

<span class="nc" id="L30">    private final Logger logger = LoggerFactory.getLogger(SelfDescriptionPersistenceAndIndexing.class);</span>
<span class="nc" id="L31">    private final ConnectorModelCreator connectorModelCreator = new ConnectorModelCreator();</span>

    private int maxNumberOfIndexedConnectorResources;

    private boolean refreshAtBeginning;
    private int refreshHours;

    private final RepositoryFacade repositoryFacade;
    private Indexing&lt;InfrastructureComponent&gt; indexing;

    private static URI componentCatalogUri;

    static Map&lt;URI, URI&gt; replacedIds;


    /**
     * Constructor
     *
     * @param repositoryFacade
     * @param componentCatalogUri
     * @param indexing
     * @param maxNumberOfIndexedConnectorResources
     */
    public SelfDescriptionPersistenceAndIndexing(RepositoryFacade repositoryFacade,
                                                 URI componentCatalogUri,
                                                 Indexing&lt;InfrastructureComponent&gt; indexing,
                                                 int maxNumberOfIndexedConnectorResources) {
<span class="nc" id="L58">        this(repositoryFacade, componentCatalogUri, indexing,</span>
                maxNumberOfIndexedConnectorResources, false, 0);
<span class="nc" id="L60">    }</span>


    /**
     * Constructor
     *
     * @param repositoryFacade repository (triple store) to which the modifications should be stored
     * @param componentCatalogUri
     * @param indexing
     * @param maxNumberOfIndexedConnectorResources
     * @param refreshAtBeginning
     * @param refreshHours
     */
    public SelfDescriptionPersistenceAndIndexing(RepositoryFacade repositoryFacade,
                                                 URI componentCatalogUri,
                                                 Indexing&lt;InfrastructureComponent&gt; indexing,
                                                 int maxNumberOfIndexedConnectorResources,
                                                 boolean refreshAtBeginning,
<span class="nc" id="L78">                                                 int refreshHours) {</span>
<span class="nc" id="L79">        this.repositoryFacade = repositoryFacade;</span>
<span class="nc" id="L80">        this.indexing = indexing;</span>
<span class="nc" id="L81">        this.maxNumberOfIndexedConnectorResources = maxNumberOfIndexedConnectorResources;</span>
<span class="nc" id="L82">        SelfDescriptionPersistenceAndIndexing.componentCatalogUri = componentCatalogUri;</span>
<span class="nc" id="L83">        Date date = new Date();</span>

        // 1. refresh at beginning, refreshHours &gt; 0
<span class="nc bnc" id="L86" title="All 4 branches missed.">        if (refreshAtBeginning &amp;&amp; refreshHours &gt; 0) {</span>
<span class="nc" id="L87">            Timer timer = new Timer();</span>

            //Regularly recreate the index to keep index and triple store in sync
            //The triple store is considered as single source of truth, so the index is dropped and recreated from the triple store
<span class="nc" id="L91">            timer.schedule(new TimerTask() {</span>
                public void run() {
<span class="nc" id="L93">                    refreshIndex();</span>
<span class="nc" id="L94">                }</span>
            }, date, refreshHours * 60 * 60 * 1000); //12*60*60*1000 add 12 hours delay between job executions.
<span class="nc" id="L96">        } else</span>
        // 2. refresh at beginning, refreshHours = 0 --&gt; no periodical refreshing
<span class="nc bnc" id="L98" title="All 4 branches missed.">        if(refreshAtBeginning &amp;&amp; refreshHours == 0) {</span>
<span class="nc" id="L99">            refreshIndex();</span>
        } else
        // 3. no refresh at beginning, refreshHours &gt; 0
<span class="nc bnc" id="L102" title="All 4 branches missed.">        if (!refreshAtBeginning &amp;&amp; refreshHours &gt; 0) {</span>
<span class="nc" id="L103">            Timer timer = new Timer();</span>
<span class="nc" id="L104">            date.setTime(date.getTime() + refreshHours * 60 * 60 * 1000); // the first refresh shall happen after 'refreshHours'</span>

<span class="nc" id="L106">            timer.schedule(new TimerTask() {</span>
                public void run() {
<span class="nc" id="L108">                    refreshIndex();</span>
<span class="nc" id="L109">                }</span>
            }, date, refreshHours * 60 * 60 * 1000); //12*60*60*1000 add 12 hours delay between job executions.
        } else
        // 4. no refreshing at all
        {
            // do nothing
        }


<span class="nc" id="L118">        Serializer.addKnownNamespace(&quot;owl&quot;, &quot;http://www.w3.org/2002/07/owl#&quot;);</span>
<span class="nc" id="L119">    }</span>

    public void setIndexing(Indexing&lt;InfrastructureComponent&gt; indexing)
    {
<span class="nc" id="L123">        this.indexing = indexing;</span>
<span class="nc" id="L124">    }</span>


    /**
     * Setter for the context document URL. Typically extracted from the application.properties
     *
     * @param contextDocumentUrl the context document URL to be used
     */
    public void setContextDocumentUrl(String contextDocumentUrl) {
<span class="nc" id="L133">        connectorModelCreator.setContextFetchStrategy(JsonLdContextFetchStrategy.FROM_URL, contextDocumentUrl);</span>
<span class="nc" id="L134">    }</span>

    /**
     * Function to refresh the index. The index is dropped entirely and recreated from the triple store
     * This keeps the index and triple store in sync, while respecting the triple store as single source of truth
     */
    public void refreshIndex() {
        //Recreate the index to delete everything
        try {
<span class="nc" id="L143">            logger.info(&quot;Refreshing indices.&quot;);</span>
<span class="nc" id="L144">            indexing.recreateIndex(&quot;registrations&quot;);</span>

            //If exists, recreate the separate resources index, too
            try {
<span class="nc" id="L148">                indexing.recreateIndex(&quot;resources&quot;);</span>
            }
<span class="nc" id="L150">            catch (Exception e) {</span>
<span class="nc" id="L151">                logger.warn(&quot;Could not create an empty 'resources' index: &quot;, e);</span>
<span class="nc" id="L152">            }</span>

<span class="nc" id="L154">            List&lt;String&gt; activeGraphs = repositoryFacade.getActiveGraphs();</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">            if(activeGraphs.isEmpty()) //Nothing to index. Return here to make sure that in case no active graphs exist, inactive ones are also ignored</span>
            {
<span class="nc" id="L157">                return;</span>
            }

            //Iterate over all active graphs, i.e. non-passivated and non-deleted graphs
<span class="nc bnc" id="L161" title="All 2 branches missed.">            for (String graph : activeGraphs) {</span>
                try { //Do a try-catch here, so that one problematic connector does not destroy the entire reindexing process
                    //Add each connector to the index
<span class="nc" id="L164">                    logger.info(&quot;Adding connector &quot; + graph + &quot; to index.&quot;);</span>
<span class="nc" id="L165">                    indexing.add(repositoryFacade.getConnectorFromTripleStore(new URI(graph)));</span>
                }
<span class="nc" id="L167">                catch (IOException | URISyntaxException | RejectMessageException e) {</span>
<span class="nc" id="L168">                    logger.error(&quot;Failed to re-index connector &quot; + graph, e);</span>
<span class="nc" id="L169">                }</span>
<span class="nc" id="L170">            }</span>
<span class="nc" id="L171">        } catch (ConnectException ignored) {</span>
<span class="nc" id="L172">            logger.warn(&quot;Could not connect to indexing. Ignoring recreation of index.&quot;);</span>
        } //Prevent startup error in case no indexing was started
<span class="nc" id="L174">        catch (IOException e) {</span>
<span class="nc" id="L175">            logger.error(&quot;Failed to refresh index: &quot;, e);</span>
<span class="nc" id="L176">        }</span>
<span class="nc" id="L177">    }</span>

    /**
     * Small utility function to replace URIs in a string
     *
     * @param input  String in which URI is to be replaced
     * @param oldURI old URI
     * @param newURI new URI
     * @return updated string
     */
    static private String doReplace(String input, URI oldURI, URI newURI) {
        //Store the original URI, so that we can add an owl:sameAs statement, indicating the original URI
<span class="nc" id="L189">        replacedIds.put(oldURI, newURI);</span>
        //Make sure that we replace only &quot;full URIs&quot; and don't replace the URI if it is only part of a longer URI
<span class="nc" id="L191">        return input.replace(&quot;\&quot;&quot; + oldURI + &quot;\&quot;&quot;, &quot;\&quot;&quot; + newURI + &quot;\&quot;&quot;);</span>
    }

    /**
     * Minimal utility function to turn a connector into a URI matching the REST scheme
     *
     * @param connectorUri Original connector URI
     * @return new connector URI
     */
    static URI rewriteConnectorUri(URI connectorUri) {
<span class="nc" id="L201">        return URI.create(componentCatalogUri.toString() + connectorUri.hashCode());</span>
    }

    /**
     * Main rewrite function, rewriting all URIs contained in a Resource object to match the REST scheme of this broker
     *
     * @param currentString Resource as String (possibly already partly translated)
     * @param resource      Resource as Object
     * @param catalogUri    URI of the catalog containing the Resource
     * @return Resource in String representation with rewritten URIs
     * @throws URISyntaxException, if malformed URIs are encountered
     */
    static String rewriteResource(String currentString, Resource resource, URI catalogUri) throws URISyntaxException {
        //Was the resource rewritten already?
<span class="nc bnc" id="L215" title="All 2 branches missed.">        if(resource.getId().toString().startsWith(componentCatalogUri.toString()))</span>
        {
<span class="nc" id="L217">            return currentString;</span>
        }
<span class="nc" id="L219">        URI resourceUri = new URI(catalogUri + &quot;/&quot; + resource.getId().hashCode());</span>

        //First big block is about contracts attached to a resource
<span class="nc bnc" id="L222" title="All 4 branches missed.">        if (resource.getContractOffer() != null &amp;&amp; !resource.getContractOffer().isEmpty()) {</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">            for (ContractOffer contractOffer : resource.getContractOffer()) {</span>
                //Replace original URI of contract offer with a new one, which is in &quot;our domain&quot;
                //This allows us to provide further details on this object if requested
<span class="nc" id="L226">                URI contractOfferUri = new URI(resourceUri + &quot;/&quot; + contractOffer.getId().hashCode());</span>
<span class="nc" id="L227">                currentString = doReplace(currentString, contractOffer.getId(), contractOfferUri);</span>

                //There can be a number of different Rules: Obligations/Duties, Prohibitions and Permissions
<span class="nc" id="L230">                Map&lt;Rule, URI&gt; allRules = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L231" title="All 4 branches missed.">                if (contractOffer.getObligation() != null &amp;&amp; !contractOffer.getObligation().isEmpty()) {</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">                    for (Duty duty : contractOffer.getObligation()) {</span>
<span class="nc" id="L233">                        allRules.put(duty, new URI(contractOfferUri.toString() + &quot;/&quot; + duty.getId().hashCode()));</span>
<span class="nc" id="L234">                    }</span>
                }
<span class="nc bnc" id="L236" title="All 4 branches missed.">                if (contractOffer.getPermission() != null &amp;&amp; !contractOffer.getPermission().isEmpty()) {</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">                    for (Permission permission : contractOffer.getPermission()) {</span>
<span class="nc" id="L238">                        allRules.put(permission, new URI(contractOfferUri.toString() + &quot;/&quot; + permission.getId().hashCode()));</span>
<span class="nc bnc" id="L239" title="All 4 branches missed.">                        if (permission.getPreDuty() != null &amp;&amp; !permission.getPreDuty().isEmpty()) {</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">                            for (Duty duty : permission.getPreDuty()) {</span>
<span class="nc" id="L241">                                allRules.put(duty, new URI(contractOfferUri.toString() + &quot;/&quot; + permission.getId().hashCode() + &quot;/&quot; + duty.getId().hashCode()));</span>
<span class="nc" id="L242">                            }</span>
                        }
<span class="nc bnc" id="L244" title="All 4 branches missed.">                        if (permission.getPostDuty() != null &amp;&amp; !permission.getPostDuty().isEmpty()) {</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">                            for (Duty duty : permission.getPostDuty()) {</span>
<span class="nc" id="L246">                                allRules.put(duty, new URI(contractOfferUri.toString() + &quot;/&quot; + permission.getId().hashCode() + &quot;/&quot; + duty.getId().hashCode()));</span>
<span class="nc" id="L247">                            }</span>
                        }
<span class="nc" id="L249">                    }</span>
                }
<span class="nc bnc" id="L251" title="All 4 branches missed.">                if (contractOffer.getProhibition() != null &amp;&amp; !contractOffer.getProhibition().isEmpty()) {</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">                    for (Prohibition prohibition : contractOffer.getProhibition()) {</span>
<span class="nc" id="L253">                        allRules.put(prohibition, new URI(contractOfferUri.toString() + &quot;/&quot; + prohibition.getId().hashCode()));</span>
<span class="nc" id="L254">                    }</span>
                }
<span class="nc bnc" id="L256" title="All 2 branches missed.">                if (!allRules.isEmpty()) {</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">                    for (Map.Entry&lt;Rule, URI&gt; ruleEntry : allRules.entrySet()) {</span>
<span class="nc" id="L258">                        currentString = doReplace(currentString, ruleEntry.getKey().getId(), ruleEntry.getValue());</span>
<span class="nc bnc" id="L259" title="All 4 branches missed.">                        if (ruleEntry.getKey().getConstraint() != null &amp;&amp; !ruleEntry.getKey().getConstraint().isEmpty()) {</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">                            for (AbstractConstraint abstractConstraint : ruleEntry.getKey().getConstraint()) {</span>
<span class="nc" id="L261">                                currentString = doReplace(currentString, abstractConstraint.getId(), new URI(ruleEntry.getValue() + &quot;/&quot; + abstractConstraint.getId().hashCode()));</span>
<span class="nc" id="L262">                            }</span>
                        }
<span class="nc" id="L264">                    }</span>
                }

<span class="nc bnc" id="L267" title="All 2 branches missed.">                if (contractOffer.getContractDocument() != null) {</span>
<span class="nc" id="L268">                    currentString = doReplace(currentString, contractOffer.getContractDocument().getId(), new URI(contractOfferUri + &quot;/&quot; + contractOffer.getContractDocument().getId().hashCode()));</span>
                }

<span class="nc" id="L271">            }</span>
        }

        //Contract has been handled. Next, rewrite the URI of the Resource itself
<span class="nc" id="L275">        currentString = doReplace(currentString, resource.getId(), resourceUri);</span>

        //Iterate over endpoints. For each present, replace URI
<span class="nc bnc" id="L278" title="All 4 branches missed.">        if (resource.getResourceEndpoint() != null &amp;&amp; !resource.getResourceEndpoint().isEmpty()) {</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">            for (ConnectorEndpoint connectorEndpoint : resource.getResourceEndpoint()) {</span>
<span class="nc" id="L280">                URI endpointUri = new URI(resourceUri + &quot;/&quot; + connectorEndpoint.getId().hashCode());</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">                if (connectorEndpoint.getEndpointArtifact() != null) {</span>
<span class="nc" id="L282">                    currentString = doReplace(currentString, connectorEndpoint.getEndpointArtifact().getId(), new URI(endpointUri + &quot;/&quot; + connectorEndpoint.getEndpointArtifact().getId().hashCode()));</span>
                }

<span class="nc" id="L285">                currentString = doReplace(currentString, connectorEndpoint.getId(), endpointUri);</span>
<span class="nc" id="L286">            }</span>

        }

        //Iterate over Representations. If Representation present, adapt string of Representation and, if present, Artifact
<span class="nc bnc" id="L291" title="All 2 branches missed.">        if (resource.getRepresentation() != null) {</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">            for (Representation representation : resource.getRepresentation()) {</span>
<span class="nc" id="L293">                URI representationURI = new URI(resourceUri + &quot;/&quot; + representation.getId().hashCode());</span>
<span class="nc" id="L294">                currentString = doReplace(currentString, representation.getId(), representationURI);</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">                if (representation.getInstance() != null) {</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">                    for (RepresentationInstance artifact : representation.getInstance()) {</span>
<span class="nc" id="L297">                        currentString = doReplace(currentString, artifact.getId(), new URI(representationURI + &quot;/&quot; + artifact.getId().hashCode()));</span>
<span class="nc" id="L298">                    }</span>
                }
<span class="nc" id="L300">            }</span>
        }

<span class="nc" id="L303">        return currentString;</span>
    }

    /**
     * This function replaces URIs of an infrastructure component (component + catalog + resources + representations + artifacts)
     * The new URIs match a scheme suitable for a RESTful API
     *
     * @param infrastructureComponent original InfrastructureComponent
     * @return new InfrastructureComponent with different IDs
     * @throws IOException        if parsing of the updated component fails
     * @throws URISyntaxException if an invalid URI is created during this process
     */
    private InfrastructureComponent replaceIds(InfrastructureComponent infrastructureComponent) throws IOException, URISyntaxException, RejectMessageException {
        //Collect all relevant IDs of IDS items (connector, catalogs, resources, representations, artifacts) replace them later
        //New object is handled, reset the replaced IDs
<span class="nc" id="L318">        replacedIds = new HashMap&lt;&gt;();</span>
        //TODO: Ideally, use relative URIs: &quot;./ + hashCode&quot; instead, but Serializer (Jena) fails on that. We don't really want to store the full URI here, as that makes the broker un-portable
<span class="nc bnc" id="L320" title="All 2 branches missed.">        if (infrastructureComponent.getId() == null) {</span>
<span class="nc" id="L321">            throw new RejectMessageException(RejectionReason.MALFORMED_MESSAGE, new NullPointerException(&quot;Connector did not provide a URI&quot;));</span>
        }

        //Rewrite URI of the connector
<span class="nc" id="L325">        URI infrastructureComponentUri = rewriteConnectorUri(infrastructureComponent.getId());</span>
<span class="nc" id="L326">        String currentString = new Serializer().serialize(infrastructureComponent);</span>
<span class="nc" id="L327">        currentString = doReplace(currentString, infrastructureComponent.getId(), infrastructureComponentUri);</span>

        //If connector is holding catalogs, rewrite them and their contents
<span class="nc bnc" id="L330" title="All 2 branches missed.">        if (((Connector) infrastructureComponent).getResourceCatalog() != null) {</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">            for (ResourceCatalog resourceCatalog : ((Connector) infrastructureComponent).getResourceCatalog()) {</span>
<span class="nc" id="L332">                URI catalogUri = new URI(infrastructureComponentUri + &quot;/&quot; + resourceCatalog.getId().hashCode());</span>
<span class="nc" id="L333">                currentString = doReplace(currentString, resourceCatalog.getId(), catalogUri);</span>

<span class="nc" id="L335">                Set&lt;Resource&gt; resourcesToHandle = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">                if (resourceCatalog.getRequestedResourceAsObject() != null) {  //List&lt;Resource&gt; getRequestedResourceAsObject</span>
<span class="nc" id="L337">                    resourcesToHandle.addAll(resourceCatalog.getRequestedResource());</span>
                }
<span class="nc bnc" id="L339" title="All 2 branches missed.">                if (resourceCatalog.getRequestedResource() != null) {  //List&lt;Resource&gt; getRequestedResourceAsObject</span>
<span class="nc" id="L340">                    resourcesToHandle.addAll(resourceCatalog.getRequestedResource());</span>
                }
<span class="nc bnc" id="L342" title="All 2 branches missed.">                for (Resource currentResource : resourcesToHandle) {</span>
<span class="nc" id="L343">                    currentString = rewriteResource(currentString, currentResource, catalogUri);</span>
<span class="nc" id="L344">                }</span>
<span class="nc" id="L345">            }</span>
        }
        //Now that we replaced all the IDs, add owl:sameAs statements and then parse
<span class="nc" id="L348">        return new Serializer().deserialize(addSameAsStatements(currentString), InfrastructureComponent.class);</span>
    }

    /**
     * This internal function adds the replaced URIs as owl:sameAs statements to preserve the original URIs
     *
     * @param jsonLd RDF string after replacements
     * @return Apache Jena Model with additional sameAs statements
     */
    static Model addSameAsStatements(String jsonLd) {
<span class="nc" id="L358">        Model model = ModelFactory.createDefaultModel();</span>
<span class="nc" id="L359">        RDFDataMgr.read(model, new ByteArrayInputStream(jsonLd.getBytes(StandardCharsets.UTF_8)), RDFLanguages.JSONLD);</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">        for (Map.Entry&lt;URI, URI&gt; entry : replacedIds.entrySet()) {</span>
<span class="nc" id="L361">            model.add(ResourceFactory.createStatement( //Add a new triple to the model</span>
<span class="nc" id="L362">                    ResourceFactory.createResource(entry.getValue().toString()), //Subject: The new URI</span>
<span class="nc" id="L363">                    ResourceFactory.createProperty(&quot;http://www.w3.org/2002/07/owl#sameAs&quot;), //Predicate: owl:sameAs</span>
<span class="nc" id="L364">                    ResourceFactory.createResource(entry.getKey().toString()))); //Object: The original URI</span>
<span class="nc" id="L365">        }</span>
<span class="nc" id="L366">        return model;</span>
    }


    /**
     * Function to persist and index modifications to an existing connector
     *
     * @param infrastructureComponent The updated connector which was announced to the broker
     * @throws IOException            thrown, if the connection to the repository could not be established
     * @throws RejectMessageException thrown, if the update is not permitted, e.g. because the connector was previously deleted, or if an internal error occurs
     */
    @Override
    public URI updated(InfrastructureComponent infrastructureComponent) throws IOException, RejectMessageException {
<span class="nc" id="L379">        URI connectorUri = rewriteConnectorUri(infrastructureComponent.getId());</span>
<span class="nc" id="L380">        boolean wasActive = repositoryFacade.graphIsActive(connectorUri.toString());</span>
<span class="nc" id="L381">        boolean existed = repositoryFacade.graphExists(connectorUri.toString());</span>

        //Replace URIs in this infrastructureComponent with URIs matching our scheme. This is required for a RESTful API
        //TODO: Do the same for resources (or at ParIS, for participants)
        try {
<span class="nc" id="L386">            infrastructureComponent = replaceIds(infrastructureComponent);</span>
<span class="nc" id="L387">        } catch (URISyntaxException e) {</span>
<span class="nc" id="L388">            throw new IOException(e);</span>
<span class="nc" id="L389">        }</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">        if (!existed) {</span>
<span class="nc" id="L391">            logger.info(&quot;New connector registered: &quot; + infrastructureComponent.getId().toString());</span>
<span class="nc" id="L392">            addToTriplestore(infrastructureComponent.toRdf());</span>
        } else {
<span class="nc" id="L394">            logger.info(&quot;Updating a connector which is already known to the broker: &quot; + infrastructureComponent.getId().toString());</span>
<span class="nc" id="L395">            updateTriplestore(infrastructureComponent.toRdf());</span>
        }
        //We need to reflect the changes in the index.
        //If the connector was passive before, the document was deleted from the index, so we need to recreate it
<span class="nc" id="L399">        infrastructureComponent = repositoryFacade.getReducedConnector(infrastructureComponent.getId(), maxNumberOfIndexedConnectorResources);</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">        if (wasActive) { //Connector exists in index - update it</span>
            try {
<span class="nc" id="L402">                indexing.update(infrastructureComponent);</span>
<span class="nc" id="L403">            } catch (Exception e) {</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">                if (e.getMessage().contains(&quot;document_missing_exception&quot;)) {</span>
<span class="nc" id="L405">                    indexing.add(infrastructureComponent);</span>
                } else {
<span class="nc" id="L407">                    logger.error(&quot;ElasticsearchStatusException caught with message &quot; + e.getMessage());</span>
<span class="nc" id="L408">                    throw new RejectMessageException(RejectionReason.INTERNAL_RECIPIENT_ERROR, e);</span>
                }
<span class="nc" id="L410">            }</span>
        } else { //Connector does not exist in index - create it
<span class="nc" id="L412">            indexing.add(infrastructureComponent);</span>
        }
        //return the (rewritten) URI of the infrastructure component
<span class="nc" id="L415">        return infrastructureComponent.getId();</span>
    }

    /**
     * Internal function which should only be called from the available function. It applies the changes to the triple store
     *
     * @param selfDescriptionJsonLD String representation of the connector to be added to triple store
     * @throws IOException            thrown, if the changes could not be applied to the triple store
     * @throws RejectMessageException thrown, if the changes are illegal, or if an internal error has occurred
     */
    private void addToTriplestore(String selfDescriptionJsonLD) throws IOException, RejectMessageException {
<span class="nc" id="L426">        ConnectorModelCreator.InnerModel result = connectorModelCreator.toModel(selfDescriptionJsonLD);</span>
<span class="nc" id="L427">        repositoryFacade.addStatements(result.getModel(), result.getNamedGraph().toString());</span>
<span class="nc" id="L428">    }</span>

    /**
     * Internal function which should only be called from the updated function. It applies the changes to the triple store
     *
     * @param selfDescriptionJsonLD String representation of the connector which needs to be updated
     * @throws IOException thrown, if the changes could not be applied to the triple store
     */
    private void updateTriplestore(String selfDescriptionJsonLD) throws IOException, RejectMessageException {
<span class="nc" id="L437">        ConnectorModelCreator.InnerModel result = connectorModelCreator.toModel(selfDescriptionJsonLD);</span>
<span class="nc" id="L438">        repositoryFacade.replaceStatements(result.getModel(), result.getNamedGraph().toString());</span>
<span class="nc" id="L439">    }</span>

    /**
     * Function to mark a given Connector as deleted/passivated in the triple store and delete the Connector from the index
     *
     * @param issuerConnector A URI reference to the connector which is now inactive
     * @throws IOException            if the connection to the triple store could not be established
     * @throws RejectMessageException if the operation is not permitted, e.g. because one is trying to passivate a Connector which was previously deleted or due to an internal error
     */
    @Override
    public void unavailable(URI issuerConnector) throws IOException, RejectMessageException {
        //Turn graph into a passive one
<span class="nc" id="L451">        URI rewrittenConnectorUri = rewriteConnectorUri(issuerConnector);</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">        if (repositoryFacade.graphIsActive(rewrittenConnectorUri.toString())) {</span>
<span class="nc" id="L453">            repositoryFacade.changePassivationOfGraph(rewrittenConnectorUri.toString(), false);</span>
        } else {
<span class="nc" id="L455">            throw new RejectMessageException(RejectionReason.NOT_FOUND, new NullPointerException(&quot;The connector you are trying to remove was not found&quot;));</span>
        }

        //Remove the passivated graph from indexing. Upon re-activating, this will be undone
<span class="nc" id="L459">        indexing.delete(rewrittenConnectorUri);</span>
<span class="nc" id="L460">    }</span>


    /**
     * Utility function to evaluate a given query (in a re-formulated way, respecting passivation and hiding underlying structure of named graphs)
     *
     * @param queryString Query to be evaluated
     * @return Query result in String format
     * @throws RejectMessageException, if the query is illegal or if the index is empty
     */
    @Override
    public String getResults(String queryString) throws RejectMessageException {
<span class="nc" id="L472">        return new GenericQueryEvaluator(repositoryFacade).getResults(queryString);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>